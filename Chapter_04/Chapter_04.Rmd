---
title: "Chapter 4"
output: html_document
date: '2023-06-22'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##1
With the vector: foo <- c(7, 1, 7, 10, 5, 9, 10, 3, 10, 8); identify the elements greater than 5 or equal to 2.
```{r}
foo <- c(7, 1, 7, 10, 5, 9, 10, 3, 10, 8)
foo[foo > 5 | foo == 2]
```

##2
With the vector: bar <- c(8, 8, 4, 4, 5, 1, 5, 6, 6, 8) identify the elements less than or equal to 6 AND not equal to 4.

```{r}
bar <- c(8, 8, 4, 4, 5, 1, 5, 6, 6, 8)
bar[bar <= 6 & bar != 4]
```

##3
With the vector: foo <- c(7, 5, 6, 1, 2, 10, 8, 3, 8, 2); store a new vector bar which has the elements from foo that are greater than or equal to 5.
```{r}
foo <- c(7, 5, 6, 1, 2, 10, 8, 3, 8, 2)
bar <- foo[foo >= 5]
bar
```

##4
With the vector: bar <- c(7, 5, 6, 10, 8, 8) create a 2X3 matrix called baz in row-wise fashion; then replace all values of baz that are equal to 8 with the square of the value in the first row, second column 
```{r}
baz <- matrix(data = bar, nrow = 2, ncol = 3, byrow = TRUE)
baz
baz[baz == 8] <- baz[1, 2]^2
baz
```

##5
Confirm all values of the matrix 'baz' are less than equal to 25 and greater than 4
```{r}
all(baz <= 25 & baz > 4)
```

##6
With the vector: qux <- c(10, 5, 1, 4, 7, 4, 3, 3, 1, 3, 4, 3, 1, 7, 8, 3, 7, 3) define a 3x2x3 array called qux_array. Then show the indexes of qux_array where the values are equal to 4 or equal to 3.
```{r}
qux <- c(10, 5, 1, 4, 7, 4, 3, 3, 1, 3, 4, 3, 1, 7, 8, 3, 7, 3)
qux_array <- array(data = qux, dim = c(3, 2, 3))
which(qux_array == 4 | qux_array == 3, arr.ind = TRUE)
```

##7
With the vector foo <- c(7, 5, 6, 1, 2, 10, 8, 3, 8, 2); extract every second value from foo [Use a logic vector].
```{r}
foo[c(F,T)]
```

##8
With two variables defined: num1 <- 4 and num2 <- 0.75. Produce the output:

[1] "The result of multiplying 4 by 0.75 is 3"

(but make sure it would work for any numbers.)
```{r}
num1 <- 4
num2 <- 0.75
paste("The result of multiplying", num1, "by", num2, "is", num1 * num2, sep = " ")
```

##9
With a variable defined: original_path <- "/Users/tdavies/Documents/RBook", replace the "tdavies" and change the path to your abreviation "jbuss"
```{r}
original_path <- "/Users/tdavies/Documents/RBook"
sub("tdavies", "jbuss", original_path)
```

##10
With the variable defined: bar <- "How much wood could a woodchuck chuck" replace each occurrence of "wood" with "metal"

```{r}
bar <- "How much wood could a woodchuck chuck"
gsub("wood","metal", bar)
```

##11
With the string: deal <- "Two 6-packs for $12.99" check that the substring beginning with character 5 and ending with character 10 is "6-pack"

```{r}
deal <- "Two 6-packs for $12.99"
substr(deal, 5, 10) == "6-pack"
```

##12
With the string: deal <- "Two 6-packs for $12.99" change it to a better deal of "$10.99"
```{r}
sub("2", "0", deal)
```

##13
Create a factor vector "marital_status" that identifies 4 individuals as being single, married, married and single; however add the "divorced" factor as a placeholder level [Put them in a "standard" progression of: single, married, divorced]
```{r}
marital_status <- factor(c("single", "married", "married", "single"), levels = c("single", "married", "divorced"))
marital_status
```

##14
What is the result of trying to assign a factor that is outside of the predefined levels?

For example trying to assign a "widowed" value to a factor that only has the 3 values: "single", "married", and "divorced"
```{r}
x[4] <- "widowed"
```

##15
Add a new level "widowed" to the factor marital_status, which currently only has "single" "married" and "divorced"

```{r}
levels(marital_status) <- c(levels(marital_status), "widowed")
```

